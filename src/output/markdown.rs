use crate::output::{FullSqlStatementLockTrace, FullTraceData, LintReport, TracedLock};

/// Render a markdown table header row
pub fn theader(header: &[&str]) -> String {
    let h = header.join(" | ");
    let dashes = header
        .iter()
        .map(|h| ["-"].repeat(h.len()).join(""))
        .collect::<Vec<_>>()
        .join("-|-");
    format!("| {} |\n|-{}-|\n", h, dashes)
}

/// Render a markdown table row
pub fn trow(row: &[&str]) -> String {
    format!("| {} |\n", row.join(" | "))
}

/// Render a lock table header
pub fn lock_header() -> String {
    theader(&["Schema", "Object", "Mode", "Relkind", "OID", "Safe"])
}

/// Render a lock row
pub fn lock_row(lock: &TracedLock) -> String {
    trow(&[
        format!("`{}`", lock.schema).as_str(),
        format!("`{}`", lock.object_name).as_str(),
        format!("`{}`", lock.mode).as_str(),
        lock.relkind,
        lock.oid.to_string().as_str(),
        match lock.maybe_dangerous {
            true => "❌",
            false => "✅",
        },
    ])
}

/// Render a markdown report from a `FullTraceData`
pub fn to_markdown(trace: &FullTraceData) -> anyhow::Result<String> {
    let mut result = String::new();
    result.push_str(&format!(
        "## Eugene 🔒 trace report of `{}`\n\n",
        trace.name.as_deref().unwrap_or("unnamed")
    ));

    if !trace.skip_summary {
        result.push_str("This is a human readable lock tracing and migration report generated by \
        [eugene](https://github.com/kaaveland/eugene) to assist you in writing safer database migration scripts.\n\n");
        result.push_str("Here are some tips for reading it:\n\
        - A lock is called **dangerous** ❌ if it will cause concurrent queries to **wait** for the migration to complete\n\
        - You read that right, once a lock is acquired, it is only released at the end of the script\n\
        - Eugene will tell you what kinds of queries **dangerous** locks would block in a summary\n\
        - **Hints** can sometimes help you avoid dangerous locks, or hold them for a shorter time\n\
        - It is hard to avoid dangerous locks, but we should minimize time spent while holding them\n\
        - Sometimes seemingly fast migration scripts cause long outages because of lock queues, [here is an example scenario](https://kaveland.no/careful-with-that-lock-eugene.html)\n\
\n");

        result.push_str("There is a summary section for the entire script at the start of the report \
        and then a section for each statement in the script, that goes over the state of the database \
        at the time the script was executed, as well as effects or hints specific to that particular \
        statement\n\n");
        result.push_str(&summary_section(trace));
    }

    for statement in trace.statements.iter() {
        result.push_str(&statement_section(statement));
    }
    Ok(result)
}

pub fn statement_section(statement: &FullSqlStatementLockTrace) -> String {
    let mut result = String::new();
    result.push_str(&format!(
        "### Statement number {} for {} ms\n\n",
        statement.statement_number_in_transaction, statement.duration_millis
    ));
    result.push_str("### SQL\n\n");
    result.push_str("```sql\n");
    result.push_str(&statement.sql);
    result.push_str("\n```\n\n");
    result.push_str("#### Locks at start\n\n");
    if statement.locks_at_start.is_empty() {
        result.push_str("No locks held at the start of this statement.\n\n");
    } else {
        result.push_str(lock_header().as_str());
        for lock in statement.locks_at_start.iter() {
            result.push_str(lock_row(lock).as_str());
        }
        result.push('\n');
    }
    result.push_str("### New locks taken\n\n");
    if statement.new_locks_taken.is_empty() {
        result.push_str("No new locks taken by this statement.\n\n");
    } else {
        result.push_str(&theader(&[
            "Schema", "Object", "Mode", "Relkind", "OID", "Safe",
        ]));
        for lock in statement.new_locks_taken.iter() {
            result.push_str(lock_row(lock).as_str());
        }
    }
    result.push('\n');

    let hints = statement.triggered_hints.clone();

    if !hints.is_empty() {
        result.push_str("### Hints\n\n");
        for hint in hints {
            result.push_str(&format!(
                "##### {}\n\nID: `{}`\n\n{}. {}. A safer way is: {}.\n\n{}\n\n",
                hint.name, hint.id, hint.condition, hint.effect, hint.workaround, hint.help
            ));
        }
    }
    result
}

pub fn lint_report_to_markdown(report: &LintReport) -> String {
    let mut result = String::new();
    result.push_str(&format!(
        "## Eugene 🔒 lint report of `{}`\n\n",
        report.name.as_deref().unwrap_or("unnamed")
    ));
    result.push_str("This is a human readable SQL script safety report generated by [eugene](https://github.com/kaaveland/eugene). \
    Keep in mind that lints can be ignored by adding a `-- eugene: ignore E123` comment to the SQL statement \
    or by passing --ignore E123 on the command line.\n\n");

    if report
        .lints
        .iter()
        .flat_map(|stmt| stmt.lints.iter())
        .count()
        == 0
    {
        result.push_str("The migration script passed all the checks ✅\n\n");
    } else {
        result.push_str("The migration script did not pass all the checks ❌\n\n");
    }

    for statement in report.lints.iter() {
        result.push_str(&format!(
            "### Statement number {}\n\n",
            statement.statement_number
        ));
        result.push_str("### SQL\n\n");
        result.push_str("```sql\n");
        result.push_str(&statement.sql);
        result.push_str("\n```\n\n");
        if statement.lints.is_empty() {
            result.push_str("No checks matched for this statement. ✅\n\n");
        } else {
            result.push_str("### Lints\n\n");
            for lint in statement.lints.iter() {
                result.push_str(&format!(
                    "##### {}\n\nID: `{}`\n\n{}. {}. A safer way is: {}.\n\n{}\n\n",
                    lint.name, lint.id, lint.condition, lint.effect, lint.workaround, lint.help
                ));
            }
        }
    }

    result
}

pub fn summary_section(trace: &FullTraceData) -> String {
    let mut result = String::new();
    result.push_str("### Overall Summary\n\n");
    let headers = [
        "Started at",
        "Total duration (ms)",
        "Number of dangerous locks",
    ];
    result.push_str(&theader(&headers));
    let dangerous_locks = trace
        .all_locks_acquired
        .iter()
        .filter(|lock| lock.maybe_dangerous)
        .count();

    result.push_str(&trow(&[
        trace.start_time.to_rfc3339().as_str(),
        trace.total_duration_millis.to_string().as_str(),
        match dangerous_locks {
            0 => "0 ✅".to_string(),
            n => format!("{} ❌", n),
        }
        .as_str(),
    ]));
    result.push('\n');

    if trace.all_locks_acquired.is_empty() {
        result.push_str("\nNo locks acquired on database objects that already exist.\n\n");
    } else {
        result.push_str("#### All locks found\n\n");
        result.push_str(&theader(&[
            "Schema",
            "Object",
            "Mode",
            "Relkind",
            "OID",
            "Safe",
            "Duration held (ms)",
        ]));
        let mut time_diff = 0;
        for statement in trace.statements.iter() {
            for lock in statement.new_locks_taken.iter() {
                result.push_str(&trow(&[
                    format!("`{}`", lock.schema).as_str(),
                    format!("`{}`", lock.object_name).as_str(),
                    format!("`{}`", lock.mode).as_str(),
                    lock.relkind,
                    lock.oid.to_string().as_str(),
                    match lock.maybe_dangerous {
                        true => "❌",
                        false => "✅",
                    },
                    (trace.total_duration_millis - time_diff)
                        .to_string()
                        .as_str(),
                ]));
            }
            time_diff += statement.duration_millis;
        }
        result.push('\n');
        if dangerous_locks > 0 {
            result.push_str("#### Dangerous locks found\n\n");
            for lock in trace
                .all_locks_acquired
                .iter()
                .filter(|lock| lock.maybe_dangerous)
            {
                result.push_str(&format!(
                    "- `{}` would block the following operations on `{}.{}`:\n",
                    lock.mode, lock.schema, lock.object_name
                ));
                for query in lock.blocked_queries.iter() {
                    result.push_str(&format!("  + `{}`\n", query));
                }
            }
        }
    }
    result + "\n"
}
